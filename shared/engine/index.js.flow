/* @flow */

import type {rpc, incomingCallMapType} from '../constants/types/flow-types'
export type responseError = {
  error: (err: Object) => void
}

declare class Session {
  end (): void;
  id: SessionID;
  outgoingCall (
    method: MethodKey,
    param: ?Object,
    callback: () => void): void;
}

export type EndHandlerType = (session: Object) => void;
export type MethodKey = string;
export type SessionID = number;
export type SessionIDKey = string; // used in our maps, really converted to a string key
export type WaitingHandlerType = (waiting: boolean, method: string, sessionID: SessionID) => void;
export type ResponseType = {
  cancel: (...args: Array<any>) => void,
  result: (...args: Array<any>) => void,
  error: (...args: Array<any>) => void,
}

declare class Engine {
  reset (): void;
  rpc (params: rpc): void;
  cancelRPC (response: responseError): void;
  listenOnConnect (key: string, f: () => void): void;
  createSession (incomingCallMap: incomingCallMapType, sessionID: ?SessionID, waitingHandler: ?WaitingHandlerType): Session;
  setIncomingHandler (method: MethodKey, handler: (payload: any, response?: ?ResponseType) => void): void;
}

var engine = new Engine()

export function isRPCCancelError (err: Object) : bool { return false }
export default engine
